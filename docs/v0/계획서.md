계획서

아래 문서는 공유용 시나리오 + 구조 + 팀 공통 규칙을 포함한 계획 설명서다.
현재 합의된 방향(JPA 엔티티 = 도메인, 단 DDD 규율 강제)을 전제로 작성했다.
그대로 복사해서 Notion / Confluence / GitHub Wiki에 올려도 된다.

사이드 프로젝트 개발 시나리오 & 아키텍처 계획서

1. 프로젝트 목표
   1.1 기술적 목표

JPA 기반 실무 친화적 구조 학습

DDD 사고방식 기반 도메인 설계

엔티티 중심 설계이지만 비즈니스 로직 응집도 유지

Mock 없이 가능한 도메인 단위 테스트

유스케이스 단위 통합 테스트 분리

향후 MSA 분리 가능한 구조 유지

1.2 팀 학습 목표

JPA 연관관계, 영속성 컨텍스트 이해

Dirty Checking, Cascade, Fetch 전략 학습

“엔티티 = 도메인”의 장단점 체득

서비스 계층 비대화 방지 훈련

2. 전체 아키텍처 개요
   2.1 레이어 구조
   Controller
   ↓
   Application Service (UseCase)
   ↓
   Domain (JPA Entity = Domain Model)
   ↓
   Repository (Spring Data JPA)

2.2 핵심 원칙

비즈니스 로직은 Domain(Entity)에 존재

Service는 오케스트레이션만 담당

Repository는 조회/저장 역할만 수행

Controller는 DTO ↔ UseCase 연결만 담당

3. 개발 시나리오 흐름 (예: 주문 생성)

Controller에서 요청 DTO 수신

Application Service에서 유스케이스 시작

Domain(Entity) 생성 또는 조회

Domain 내부 메서드로 상태 변경

Repository 저장

결과 DTO 반환

Request → Controller
→ OrderService.placeOrder()
→ new Order(...)
→ order.confirm()
→ orderRepository.save(order)
→ Response

4. 도메인 설계 기준 (Entity = Domain)
   4.1 Aggregate 기준 설계

엔티티는 반드시 Aggregate Root 단위로 설계

의미 없는 엔티티 생성 금지

외부 접근은 Root를 통해서만

Order (Aggregate Root)
└─ OrderItem

5. 팀 공통 규칙 (중요 / 필수)
   5.1 엔티티 설계 규칙
   ① Setter 전면 금지

상태 변경은 의미 있는 메서드로만

public void pay() { ... }
public void cancel() { ... }

② 엔티티에 반드시 행위(비즈니스 로직)가 있어야 함

데이터 구조체처럼 사용 ❌

로직 없는 엔티티는 리뷰 단계에서 반려

③ 생성자 규칙

기본 생성자는 protected

유효성 검증은 생성자 또는 팩토리 메서드에서 수행

protected Order() {}

public Order(...) {
validate();
}

④ 연관관계 접근 규칙

Lazy 로딩 컬렉션 직접 노출 금지

읽기 전용 컬렉션 반환

public List<OrderItem> getItems() {
return List.copyOf(items);
}

⑤ equals / hashCode 규칙

식별자(ID) 기준

값 기반 비교 금지

프록시 고려 필수

⑥ 엔티티 외부로 비즈니스 로직 이동 금지

Service에 if/else 비즈니스 분기 ❌

정책/규칙은 엔티티 메서드로 이동

5.2 Service(Application) 계층 규칙

Service는 아래 역할만 허용:

트랜잭션 경계 설정

여러 도메인 간 흐름 조합

Repository 호출

외부 시스템 연계

❌ 금지 사항

상태 변경 로직

정책 판단

계산 로직

5.3 Controller 규칙

엔티티 직접 반환 ❌

DTO만 사용

인증/인가 외 비즈니스 로직 금지

6. 테스트 전략
   6.1 도메인 단위 테스트 (필수)

JPA 컨텍스트 ❌

Spring ❌

Mock ❌

순수 자바 객체 생성

@Test
void 주문은*결제되면*상태가\_변경된다() {
Order order = new Order(...);

    order.pay();

    assertThat(order.getStatus()).isEqualTo(PAID);

}

모든 핵심 비즈니스 규칙은 이 테스트로 검증

6.2 유스케이스 통합 테스트

@SpringBootTest

DB, JPA, 트랜잭션 포함

시나리오 기준 테스트

주문 생성 → 결제 → 상태 변경 확인

7. 코드 리뷰 기준 (팀 합의)

다음 항목 발견 시 반드시 리뷰 코멘트:

엔티티에 로직이 없는 경우

Service에 비즈니스 분기가 있는 경우

Setter 사용

엔티티를 Controller에서 직접 반환

테스트에서 Spring/JPA 의존이 불필요한 경우

8. 장기 관점 (리팩토링 전제)

현재 구조는 학습 + 실무 절충안이다.

향후 가능성

Domain ↔ JPA Entity 분리

Domain Event 도입

MSA 분리 시 Domain 재사용

이를 위해:

비즈니스 규칙을 엔티티에 집중

레이어 간 의존성 최소화

9. 한 줄 요약 (공유용)

“우리는 JPA 엔티티를 도메인으로 사용하되,
DDD 규율을 강제하여 로직 중심 설계를 학습한다.”
